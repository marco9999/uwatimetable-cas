package com.github.marco9999.uwatimetable;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteOpenHelper;
import android.support.annotation.IntegerRes;
import android.util.Log;

/**
 * Created by msatti on 12/04/16.
 */
class HelperTimetableDatabase extends SQLiteOpenHelper {

    static final int DATABASE_VERSION = 1;
    static final String DATABASE_NAME = "timetable.db";

    SQLiteDatabase database = null;

    HelperTimetableDatabase(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
    }

    ////////////////////
    // SQL functions. //
    ////////////////////

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(ContractTimetableDatabase.SQL_CREATE_COMMAND);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        db.execSQL(ContractTimetableDatabase.SQL_DROP_COMMAND);
        onCreate(db);
    }

    @Override
    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        onUpgrade(db, oldVersion, newVersion);
    }

    boolean openDB() {
        boolean isOpen = false;
        try {
            database = getWritableDatabase();
            if (database == null) throw new NullPointerException("HelperTimetableDatabase: openDB: getWritableDatabase() returned null!");
            isOpen = true;
        }
        catch (Exception ex) {
            Log.d(ActivityUWATimetable.LOG_TAG, "HelperTimetableDatabase: openDB: Failed to open database");
            Log.d(ActivityUWATimetable.LOG_TAG, ex.getLocalizedMessage());
        }
        return isOpen;
    }

    void closeDB() {
        database.close();
        database = null;
    }

    SQLiteDatabase getDB() {
        return database;
    }

    //////////////////////////
    // Timetable functions. //
    //////////////////////////

    boolean writeTimetableDBEntry(HolderTimetableEntry info) {
        assert (database != null);
        // info contains list of class entry parameters (in the order listed by ContractTimetableDatabase.SET_COLUMN_NAMES) through the ContentValues object underneath it.
        // The ROWID (_ID) is automatically generated by the SQL engine.

        // Insert entry into timetable database.
        long returnValue = database.insert(ContractTimetableDatabase.TABLE_NAME, null, info.getContentValues());

        // Return false if the insert function returned -1, which indicates an error.
        return !(returnValue == -1);
    }

    HolderTimetableEntry[] readAllTimetableDBEntry() {
        assert (database != null);
        // Get DB results.
        Cursor results = database.query(ContractTimetableDatabase.TABLE_NAME, null, null, null, null, null, null, null);

        // Allocate length of entryArray.
        HolderTimetableEntry[] entryArray = new HolderTimetableEntry[results.getCount()];

        // Put cursor results into holders.
        String[] tempStrArrayHolder;
        while (results.moveToNext()) {
            tempStrArrayHolder = new String[ContractTimetableDatabase.SET_COLUMN_NAMES_ID.length];
            for (int i = 0; i < ContractTimetableDatabase.SET_COLUMN_NAMES_ID.length; i++) {
                tempStrArrayHolder[i] =  results.getString(i);
            }
            entryArray[results.getPosition()] = new HolderTimetableEntry(tempStrArrayHolder, true);
        }

        // Close results cursor.
        results.close();

        return entryArray;
    }
}
